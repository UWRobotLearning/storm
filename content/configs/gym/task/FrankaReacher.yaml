# used to create the object
name: FrankaReacher

defaults:
  - robot: FrankaPanda
  - world: TableWorld

joint_control:
  n_dofs: ${task.n_dofs}
  control_dt: 0.0166 #0.02
  state_filter_coeff: {'q_pos': 0.1, 'q_vel': 0.0, 'q_acc': 0.0}

env:
  num_envs: ${...num_envs} #${resolve_default:1,${...num_envs}}
  robot: ${task.robot}
  envSpacing: 1.5
  episodeLength: 1000
  enableDebugVis: False
  controlFrequencyInv: 1
  num_objects: 0
  aggregateMode: 3
  # actionScale: 1.0 #7.5
  # dofVelocityScale: 0.1
  joint_control: ${..joint_control}
  joint_control_mode: 'inverse_dynamics'
  robot_p_gains: [100.0, 100.0, 100.0, 100.0, 40.0, 30.0, 20.0]
  robot_d_gains: [10.0, 10.0, 10.0, 10.0, 7.5, 5.0, 1.0]
  robot_z_offset: 0.0

  asset:
    # assetFileNameRobot: ${task.robot_urdf}
  # set to True if you use camera sensors in the environment
  enableCameraSensors: False

  physics_engine: ${...physics_engine}
  sim:
    dt: 0.0166 # 1/60
    substeps: 1
    up_axis: "z"
    use_gpu_pipeline: ${....use_gpu_pipeline}
    gravity: [0.0, 0.0, -9.81]
    physx:
      num_threads: ${.....num_threads}
      solver_type: ${.....solver_type}
      use_gpu: ${contains:"cuda",${.....sim_device}} # set to False to run on CPU
      num_position_iterations: 12
      num_velocity_iterations: 1
      contact_offset: 0.005
      rest_offset: 0.0
      bounce_threshold_velocity: 0.2
      max_depenetration_velocity: 1000.0
      default_buffer_size_multiplier: 5.0
      max_gpu_contact_pairs: 1048576 # 1024*1024
      num_subscenes: ${.....num_subscenes}
      contact_collection: 0 # 0: CC_NEVER (don't collect contact info), 1: CC_LAST_SUBSTEP (collect only contacts on last substep), 2: CC_ALL_SUBSTEPS (broken - do not use!)


task:
  robot: ${task.robot}
  randomize: False  
  control_space: 'acc'
  max_acc: 100.0
  max_jerk: 500.0

  world_collision_params:
    bounds: [[-0.4, -0.6, -0.2], [0.6,0.6,1.0]] 
    #bounds: [[-0.5, -0.8, 0.0],[0.5,0.8,1.0]]
    grid_resolution: 0.05

  task_specs:
    default_ee_target: [0.45, 0.0, 0.4, 0.0, 0.707, 0.707, 0.0]
    # default_ee_target: [0.6, 0.0, 0.5, 0.0, 0.707, 0.707, 0.0]
    # default_ee_target: [0.4, -0.3, 0.5, 0.0, 0.707, 0.707, 0.0]
    randomize_target_position: True
    randomize_target_rotation: True
    target_position_range: [[0.3, 0.6], [-0.2, 0.2], [0.1, 0.6]] #xyz (meters)
    target_rotation_range: [[0.0, 0.0], [0.0, 0.0], [-1.57, 1.57]] #radians

  cost:
    goal_pose:
      vec_weight: [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
      weight: [5.0, 15.0] #[10.0, 50.0] #[50.0, 100.0]
      cost_type: 'se3_twist'
      norm_type: 'l2'
      hinge_val: -1
      convergence_val: [0.0, 0.0] # orientation, position

    ee_vel_twist:
      weight: 5e-2 #1e-5 #1.0
      norm_type: 'l2'
      # hinge_val: 0.01
      # vec_weight: [1.0, 1.0, 1.0] 

    ee_acc_twist:
      weight: 0.0
      norm_type: 'l2'
      # vec_weight: [1.0, 1.0, 1.0] 

    zero_q_vel:
      weight: 0.0 #3e-2
      norm_type: 'l2'
      # hinge_val: 0.2 #0.2

    zero_q_acc:
      weight: 0.0 #0.01
      norm_type: 'l2'
      # hinge_val: -1.0

    zero_q_jerk:
      weight: 0.0 #0.01
      norm_type: 'l2'
      # hinge_val: -1.0
      
    manipulability:
      weight: 0.0 #0.5 #30.0 #30.0 #10.0 #100.0 #0.05 #0.5 #1.0
      thresh: 0.08 #0.1 #0.05 #0.03

    joint_l2:
      weight: 0.0
      norm_type: 'l2'

    smooth_cost:
      weight: 0.0
      order: 1

    primitive_collision:
      weight: 0.0 #100.0 
      distance_threshold_world: 0.03
      distance_threshold_self: 0.03

    # robot_self_collision:
    #   weight: 5000.0 #5000.0
    #   distance_threshold: 0.05

    state_bound:
      weight: 0.0 #100.0 #5000.0 
      bound_thresh: 0.03

    retract_state : [0.00, 0.0, 0.00, -1.5, 0.00, 2.0, 0.0] #check
    retract_weight: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0] #check






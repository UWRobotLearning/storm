# used to create the object
name: FrankaReacher

physics_engine: ${..physics_engine}

# if given, will override the device setting in gym. 
env:
  num_envs: ${resolve_default:1,${...num_envs}}
  envSpacing: 1.5
  episodeLength: 500
  enableDebugVis: False
  controlSpace: "vel_2"
  controlFrequencyInv: 1
  num_objects: 0
  # clipObservations: 5.0
  # # clipActions: 1.0
  aggregateMode: 3
  # actionScale: 1.0 #7.5
  # dofVelocityScale: 0.1

  asset:
    assetRoot: "../../content/assets"
    assetFileNameFranka: "urdf/franka_description/franka_panda_no_gripper_sim.urdf"

  # set to True if you use camera sensors in the environment
  enableCameraSensors: False


rollout:
  num_instances: ${task.env.num_envs}
  batch_size: 1
  horizon: 1
  control_dt: 0.0166 #0.02
  control_space: 'acc'
  n_dofs: 7
  state_filter_coeff: {'q_pos': 0.1, 'q_vel': 0.0, 'q_acc': 0.0}

  model:
    # any link that is not specified as learnable will be initialized from urdf
    urdf_path: "urdf/franka_description/franka_panda_no_gripper_sim.urdf"
    learnable_rigid_body_config:
      learnable_links: []
    name: "franka_panda"
    max_acc: 10.0 
    dt_traj_params:
      base_dt: 0.0166 #0.02 #0.0166 #0.01 #0.02
      base_ratio: 1.0
      max_dt: 0.2
    ee_link_name: "ee_link"
    init_state: [0.8, 0.3, 0.0, -1.57, 0.0, 1.86, 0.] #check
    link_names: ['panda_link1', 'panda_link2','panda_link3','panda_link4','panda_link5', 'panda_link6','panda_hand']
    # vel_scale: 1.0
    collision_spheres: '../robot/franka.yml'
    
    robot_collision_params:
      urdf_path: ${task.rollout.model.urdf_path}
      sample_points: 100
      link_names: ${task.rollout.model.link_names}
      threshold: 0.35
      collision_spheres: 'robot/franka.yml'
      self_collision_weights: 'robot_self/franka_panda_self_collision_weights_2.pt'
      n_dofs: ${task.rollout.n_dofs}

    world_collision_params:
      bounds: [[-0.4, -0.6, -0.2], [0.6,0.6,1.0]] 
      #bounds: [[-0.5, -0.8, 0.0],[0.5,0.8,1.0]]
      grid_resolution: 0.05

  task_specs:
    default_ee_target: [0.3, 0.0, 0.3, 0.0, 0.707, 0.707, 0.0]
    target_position_noise: 0.2
    target_rotation_noise: 0.0

  cost:
    goal_pose:
      vec_weight: [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
      weight: [15.0, 100.0] #[15.0, 100.0]
      hinge_val: -1
      convergence_val: [0.0, 0.0] # orientation, position

    zero_vel:
      weight: 0.0
      hinge_val: 0.2 #0.2

    zero_acc:
      weight: 0.0 #0.01
      hinge_val: -1.0
      
    null_space:
      weight: 0.0 #0.01 #0.05 #0.5 #1.0
      vec_weight: [1.0, 1.0, 1.0, 1.0, 1.0, 0.5, 0.5]
      
    manipulability:
      weight: 10.0 #10.0 #100.0 #0.05 #0.5 #1.0
      thresh: 0.03

    joint_l2:
      weight: 0.0

    ee_vel:
      weight: 0.0
      vec_weight: [1.0, 1.0, 1.0] 

    stop_cost:
      weight: 30.0 #10.0 #10.0 
      max_nlimit: 1.5 #1.5 #0.2

    stop_cost_acc:
      weight: 0.0
      max_limit: 0.1 #0.2

    # smooth: # on robot acceleration
    #   weight: 0.0 
    #   gaussian_params: {'n':0, 'c':0.2, 's':0, 'r':10.0}
    #   order: 1

    primitive_collision:
      weight: 5000.0
      distance_threshold: 0.05

    # robot_self_collision:
    #   weight: 5000.0 #5000.0
    #   distance_threshold: 0.05

    state_bound:
      weight: 5000.0 
      bound_thresh: 0.05

    retract_state : [0.00, 0.0, 0.00, -1.5, 0.00, 2.0, 0.0] #check
    retract_weight: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0] #check

mpc:
  rollout: ${task.rollout}
  world: ${task.world}
  viz_rollouts: False

  mppi:
    num_instances     : ${task.env.num_envs}
    horizon           : 30
    init_cov          : 0.1 #0.005 #.5 #.5
    gamma             : 0.99 #0.98
    n_iters           : 1
    step_size_mean    : 0.98
    step_size_cov     : 0.7
    beta              : 0.1
    alpha             : 1
    num_particles     : 1000 #10000
    update_cov        : False
    cov_type          : 'diag_AxA' # 
    kappa             : 0.005
    null_act_frac     : 0.01
    sample_mode       : 'mean'
    base_action       : 'repeat'
    squash_fn         : 'clamp'
    hotstart          : True
    normalize_returns : True
    visual_traj       : 'ee_pos_seq'
    sample_params:
      type: 'multiple'
      fixed_samples: True
      sample_ratio: {'halton': 0.0, 'halton-knot': 1.0, 'random': 0.0, 'random-knot': 0.0}
      seed: 0
      filter_coeffs: null #[0.3, 0.3, 0.4]
      knot_scale: 4
      bspline_degree: 3

train:
  agent:
    name: 'MPC'
    num_episodes: 20
    save_buffer: false
    log_freq: 50
    eval_freq: 100
    checkpoint_freq: 10000

  policy: 0.0


sim:
  dt: 0.0166 # 1/60
  substeps: 1
  up_axis: "z"
  use_gpu_pipeline: ${eq:${...pipeline},"gpu"}
  gravity: [0.0, 0.0, -9.81]
  physx:
    num_threads: ${....num_threads}
    solver_type: ${....solver_type}
    use_gpu: ${contains:"cuda",${....sim_device}} # set to False to run on CPU
    num_position_iterations: 12
    num_velocity_iterations: 1
    contact_offset: 0.005
    rest_offset: 0.0
    bounce_threshold_velocity: 0.2
    max_depenetration_velocity: 1000.0
    default_buffer_size_multiplier: 5.0
    max_gpu_contact_pairs: 1048576 # 1024*1024
    num_subscenes: ${....num_subscenes}
    contact_collection: 0 # 0: CC_NEVER (don't collect contact info), 1: CC_LAST_SUBSTEP (collect only contacts on last substep), 2: CC_ALL_SUBSTEPS (broken - do not use!)

task:
  randomize: False

defaults:
  - world: FrankaReacherWorld



rollout:
  num_instances: ${task.env.num_envs}
  control_space: ${task.task.control_space}
  max_acc: ${task.task.max_acc} #100.0 
  max_jerk: ${task.task.max_jerk}
  n_dofs: ${task.n_dofs}
  ee_link_name: ${task.ee_link_name}

  model:
    # any link that is not specified as learnable will be initialized from urdf
    urdf_path: ${task.robot_urdf}
    learnable_rigid_body_config:
      learnable_links: []
    name: "franka_panda"
    dt_traj_params:
      base_dt: 0.0166 #0.02 #0.0166 #0.01 #0.02
      base_ratio: 1.0
      max_dt: 0.166
    ee_link_name: ${task.ee_link_name}
    init_state: [0.8, 0.3, 0.0, -1.57, 0.0, 1.86, 0.] #check
    link_names: ${task.task.robot_link_names}
  
  robot_collision_params: ${task.task.robot_collision_params}
  world_collision_params: ${task.task.world_collision_params}

  # robot_collision_params:
  #   urdf_path: ${task.robot_urdf}
  #   sample_points: 100
  #   link_names: ${task.task.robot_link_names}
  #   threshold: 0.35
  #   collision_spheres: 'robot/franka.yml'
  #   self_collision_weights: 'robot_self/franka_panda_self_collision_weights_2.pt'
  #   n_dofs: ${task.rollout.n_dofs}

  # world_collision_params:
  #   bounds: [[-0.4, -0.6, -0.2], [0.6,0.6,1.0]] 
  #   #bounds: [[-0.5, -0.8, 0.0],[0.5,0.8,1.0]]
  #   grid_resolution: 0.05

  cost:
    goal_pose:
      vec_weight: [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
      weight: [5.0, 15.0] #[10.0, 50.0] #[50.0, 100.0]
      cost_type: 'se3_twist'
      norm_type: 'l2'
      hinge_val: -1
      convergence_val: [0.0, 0.0] # orientation, position

    ee_vel_twist:
      weight: 1e-5 #1.0
      norm_type: 'l2'
      # hinge_val: 0.01
      # vec_weight: [1.0, 1.0, 1.0] 

    ee_acc_twist:
      weight: 0.0
      norm_type: 'squared_l2'
      # vec_weight: [1.0, 1.0, 1.0] 

    zero_q_vel:
      weight: 3e-2
      norm_type: 'l2'
      # hinge_val: 0.2 #0.2

    zero_q_acc:
      weight: 0.0 #0.01
      norm_type: 'l2'
      # hinge_val: -1.0

    zero_q_jerk:
      weight: 0.0 #2e-3 #2e-4 
      norm_type: 'l2'
      # hinge_val: -1.0
      
    manipulability:
      weight: 0.5 #30.0 #30.0 #10.0 #100.0 #0.05 #0.5 #1.0
      thresh: 0.08 #0.1 #0.05 #0.03

    joint_l2:
      weight: 0.0
      norm_type: 'l2'

    stop_cost:
      weight: 2.0 #1.0 #30.0 #50.0 #50.0 #10.0 #10.0 
      max_nlimit: 5.0 #1.5 #0.2

    stop_cost_acc:
      weight: 0.0
      max_limit: 0.1 #0.2

    smooth_cost:
      weight: 0.0
      order: 1

    primitive_collision:
      weight: 100.0
      distance_threshold_world: 0.03
      distance_threshold_self: 0.03

    # robot_self_collision:
    #   weight: 5000.0 #5000.0
    #   distance_threshold: 0.05

    state_bound:
      weight: 100.0 
      bound_thresh: 0.03

    retract_state : [0.00, 0.0, 0.00, -1.5, 0.00, 2.0, 0.0] #check
    retract_weight: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0] #check

world: ${task.world}
viz_rollouts: False

mppi:
  state_batch_size  : 1
  horizon           : 20
  init_cov          : 0.1 #0.005 #.5 #.5
  gamma             : 0.99 
  td_lam            : 1.0
  n_iters           : 1
  step_size_mean    : 0.98
  step_size_cov     : 0.7
  beta              : 0.01
  alpha             : 1
  num_particles     : 1000
  update_cov        : False
  cov_type          : 'full_AxA'
  kappa             : 0.01
  null_act_frac     : 0.01
  cl_act_frac       : 1.0
  use_cl_std        : False #whether to use std of closed loop policy for exploration
  base_action       : 'repeat'
  squash_fn         : 'clamp'
  hotstart          : True
  normalize_returns : True
  visual_traj       : 'ee_pos_seq'
  sample_params:
    type: 'multiple'
    fixed_samples: True
    sample_ratio: {'halton': 0.0, 'halton-knot': 1.0, 'random': 0.0, 'random-knot': 0.0}
    seed: 0
    filter_coeffs: null #[0.3, 0.3, 0.4]
    knot_scale: 4
    bspline_degree: 3